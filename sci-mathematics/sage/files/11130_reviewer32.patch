# HG changeset patch
# User Jeroen Demeyer <jdemeyer@cage.ugent.be>
# Date 1306309961 -7200
# Node ID 7699ace8be6dfb76e3d88164b4d581b90bb314f1
# Parent  35cda75bc998e963b5a76e791a50a50326a8b113
Fix additional 32-bit doctest failures

diff --git a/sage/rings/number_field/number_field_ideal.py b/sage/rings/number_field/number_field_ideal.py
--- a/sage/rings/number_field/number_field_ideal.py
+++ b/sage/rings/number_field/number_field_ideal.py
@@ -1083,10 +1083,17 @@
             [1]
             sage: I._S_ideal_class_log([])
             [3]
+
+        TESTS::
+
             sage: K.<a> = QuadraticField(-974)
             sage: S = K.primes_above(2)
-            sage: [P._S_ideal_class_log(S) for P in K.primes_above(11)]
-            [[5, 2], [1, 1]]
+            sage: G = K.S_class_group(S)
+            sage: I0 = G.0.ideal(); I1 = G.1.ideal()
+            sage: for p in prime_range(100):
+            ...       for P in K.primes_above(p):
+            ...           v = P._S_ideal_class_log(S)
+            ...           assert(G(P) == G(I0^v[0] * I1^v[1]))
         """
         from sage.modules.free_module_element import vector
         from sage.rings.finite_rings.integer_mod_ring import Zmod
@@ -1105,6 +1112,9 @@
         """
         Return True iff self is the zero ideal
 
+        Note that `(0)` is a ``NumberFieldIdeal``, not a
+        ``NumberFieldFractionalIdeal``.
+
         EXAMPLES::
 
             sage: K.<a> = NumberField(x^2 + 2); K
@@ -1115,8 +1125,6 @@
             True
             sage: I
             Ideal (0) of Number Field in a with defining polynomial x^2 + 2
-
-            (0 is a NumberFieldIdeal, not a NumberFieldFractionIdeal)
         """
         return self == self.number_field().ideal(0)
 
diff --git a/sage/schemes/elliptic_curves/ell_number_field.py b/sage/schemes/elliptic_curves/ell_number_field.py
--- a/sage/schemes/elliptic_curves/ell_number_field.py
+++ b/sage/schemes/elliptic_curves/ell_number_field.py
@@ -2,14 +2,14 @@
 r"""
 Elliptic curves over number fields
 
-An elliptic curve `E` over a number field `K` can be given 
+An elliptic curve `E` over a number field `K` can be given
 by a Weierstrass equation whose coefficients lie in `K` or by
 using ``base_extend`` on an elliptic curve defined over a subfield.
 
 One major difference to elliptic curves over `\QQ` is that there
 might not exist a global minimal equation over `K`, when `K` does
 not have class number one.
-Another difference is the lack of understanding of modularity for 
+Another difference is the lack of understanding of modularity for
 general elliptic curves over general number fields.
 
 Currently Sage can obtain local information about `E/K_v` for finite places
@@ -67,11 +67,11 @@
 
 REFERENCE:
     
-- [Sil] Silverman, Joseph H. The arithmetic of elliptic curves. Second edition. Graduate Texts in    
+- [Sil] Silverman, Joseph H. The arithmetic of elliptic curves. Second edition. Graduate Texts in
   Mathematics, 106. Springer, 2009.
 
-- [Sil2] Silverman, Joseph H. Advanced topics in the arithmetic of elliptic curves. Graduate Texts in  
-  Mathematics, 151. Springer, 1994. 
+- [Sil2] Silverman, Joseph H. Advanced topics in the arithmetic of elliptic curves. Graduate Texts in
+  Mathematics, 151. Springer, 1994.
 """
 
 #*****************************************************************************
@@ -163,7 +163,7 @@
         self._point_class = ell_point.EllipticCurvePoint_number_field
 
     def simon_two_descent(self, verbose=0, lim1=5, lim3=50, limtriv=10, maxprob=20, limbigprime=30):
-        r""" 
+        r"""
         Computes lower and upper bounds on the rank of the Mordell-Weil group,
         and a list of independent points. Used internally by the :meth:`~rank`,
         :meth:`~rank_bounds` and :meth:`~gens` methods.
@@ -297,7 +297,7 @@
         
         - points - either a list of points, which must be on this
           curve, or (default) None, in which case self.gens() will be
-          used. 
+          used.
 
         - precision - number of bits of precision of result
           (default: None, for default RealField precision)
@@ -362,7 +362,7 @@
         for j in range(r):
             mat[j,j] = points[j].height(precision=precision)
         for j in range(r):
-            for k in range(j+1,r):              
+            for k in range(j+1,r):
                 mat[j,k]=((points[j]+points[k]).height(precision=precision) - mat[j,j] - mat[k,k])/2
                 mat[k,j]=mat[j,k]
         return mat
@@ -380,7 +380,7 @@
         
         EXAMPLES::
         
-            sage: E = EllipticCurve('37a1')                  
+            sage: E = EllipticCurve('37a1')
             sage: P = E(0,0)
             sage: Q = E(1,0)
             sage: E.regulator_of_points([P,Q])
@@ -392,22 +392,22 @@
         
             sage: E = EllipticCurve('5077a1')
             sage: points = [E.lift_x(x) for x in [-2,-7/4,1]]
-            sage: E.regulator_of_points(points)              
+            sage: E.regulator_of_points(points)
             0.417143558758384
             sage: E.regulator_of_points(points,precision=100)
             0.41714355875838396981711954462
         
         ::
         
-            sage: E = EllipticCurve('389a')                   
-            sage: E.regulator_of_points()             
+            sage: E = EllipticCurve('389a')
+            sage: E.regulator_of_points()
             1.00000000000000
-            sage: points = [P,Q] = [E(-1,1),E(0,-1)]          
-            sage: E.regulator_of_points(points)               
+            sage: points = [P,Q] = [E(-1,1),E(0,-1)]
+            sage: E.regulator_of_points(points)
             0.152460177943144
             sage: E.regulator_of_points(points, precision=100)
             0.15246017794314375162432475705
-            sage: E.regulator_of_points(points, precision=200) 
+            sage: E.regulator_of_points(points, precision=200)
             0.15246017794314375162432475704945582324372707748663081784028
             sage: E.regulator_of_points(points, precision=300)
             0.152460177943143751624324757049455823243727077486630817840280980046053225683562463604114816
@@ -495,7 +495,7 @@
         return forall(self.ainvs(), lambda x : x.valuation(P) >= 0)[0]
 
     def local_integral_model(self,*P):
-        r""" 
+        r"""
         Return a model of self which is integral at the prime ideal
         `P`.
 
@@ -584,7 +584,7 @@
     integral_model = global_integral_model
 
     def _reduce_model(self):
-        r""" 
+        r"""
 
         Transforms the elliptic curve to a model in which `a_1`,
         `a_2`, `a_3` are reduced modulo 2, 3, 2 respectively.
@@ -688,7 +688,7 @@
             Minimal discriminant valuation: 1
             Conductor exponent: 1
             Kodaira Symbol: I1
-            Tamagawa Number: 1, 
+            Tamagawa Number: 1,
             Local data at Fractional ideal (-3*i - 2):
             Reduction type: bad split multiplicative
             Local minimal model: Elliptic Curve defined by y^2 + (i+1)*x*y + y = x^3 over Number Field in i with defining polynomial x^2 + 1
@@ -729,7 +729,7 @@
         from sage.schemes.elliptic_curves.ell_local_data import check_prime
         P = check_prime(self.base_field(),P)
 
-        return self._get_local_data(P,proof,algorithm)       
+        return self._get_local_data(P,proof,algorithm)
 
     def _get_local_data(self, P, proof, algorithm="pari"):
         r"""
@@ -782,9 +782,9 @@
             self._local_data = {}
         except KeyError:
             pass
-        from sage.schemes.elliptic_curves.ell_local_data import EllipticCurveLocalData    
+        from sage.schemes.elliptic_curves.ell_local_data import EllipticCurveLocalData
         self._local_data[P, proof, algorithm] = EllipticCurveLocalData(self, P, proof, algorithm)
-        return self._local_data[P, proof, algorithm]       
+        return self._local_data[P, proof, algorithm]
 
     def local_minimal_model(self, P, proof = None, algorithm="pari"):
         r"""
@@ -862,10 +862,10 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_good_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_good_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), True),
             (Fractional ideal (2*a + 1), False)]
-        """    
+        """
         return self.local_data(P).has_good_reduction()
         
     def has_bad_reduction(self, P):
@@ -896,7 +896,7 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_bad_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_bad_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), False),
             (Fractional ideal (2*a + 1), True)]
         """
@@ -930,7 +930,7 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_multiplicative_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_multiplicative_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), False), (Fractional ideal (2*a + 1), False)]
         """
         return self.local_data(P).has_multiplicative_reduction()
@@ -958,7 +958,7 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_split_multiplicative_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_split_multiplicative_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), False), (Fractional ideal (2*a + 1), False)]
         """
         return self.local_data(P).has_split_multiplicative_reduction()
@@ -986,7 +986,7 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_nonsplit_multiplicative_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_nonsplit_multiplicative_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), False), (Fractional ideal (2*a + 1), False)]
         """
         return self.local_data(P).has_nonsplit_multiplicative_reduction()
@@ -1013,7 +1013,7 @@
             sage: K.<a>=NumberField(x^3-2)
             sage: P17a, P17b = [P for P,e in K.factor(17)]
             sage: E = EllipticCurve([0,0,0,0,2*a+1])
-            sage: [(p,E.has_additive_reduction(p)) for p in [P17a,P17b]]           
+            sage: [(p,E.has_additive_reduction(p)) for p in [P17a,P17b]]
             [(Fractional ideal (4*a^2 - 2*a + 1), False),
             (Fractional ideal (2*a + 1), True)]
         """
@@ -1111,9 +1111,9 @@
     def tamagawa_product_bsd(self):
         r"""
         Given an elliptic curve `E` over a number field `K`, this function returns the
-        integer `C(E/K)` that appears in the Birch and Swinnerton-Dyer conjecture accounting 
+        integer `C(E/K)` that appears in the Birch and Swinnerton-Dyer conjecture accounting
         for the local information at finite places. If the model is a global minimal model then `C(E/K)` is
-        simply the product of the Tamagawa numbers `c_v` where `v` runs over all prime ideals of `K`. Otherwise, if the model has to be changed at a place `v` a correction factor appears. 
+        simply the product of the Tamagawa numbers `c_v` where `v` runs over all prime ideals of `K`. Otherwise, if the model has to be changed at a place `v` a correction factor appears.
         The definition is such that `C(E/K)` times the periods at the infinite places is invariant
         under change of the Weierstrass model. See [Ta2] and [Do] for details.
         
@@ -1162,7 +1162,7 @@
         
         """
         da = self.local_data()
-        pr = 1 
+        pr = 1
         for dav in da:
             pp = dav.prime()
             cv = dav.tamagawa_number()
@@ -1203,8 +1203,7 @@
             sage: K.<a>=NumberField(x^2-5)
             sage: E=EllipticCurve([20, 225, 750, 625*a + 6875, 31250*a + 46875])
             sage: bad_primes = E.discriminant().support(); bad_primes
-            [Fractional ideal  (a), Fractional ideal (7/2*a - 81/2), Fractional ideal (-a - 52), Fractional ideal (2)]  # 32-bit
-            [Fractional ideal (-a), Fractional ideal (7/2*a - 81/2), Fractional ideal (-a - 52), Fractional ideal (2)]  # 64-bit
+            [Fractional ideal (-a), Fractional ideal (7/2*a - 81/2), Fractional ideal (-a - 52), Fractional ideal (2)]
             sage: [E.kodaira_symbol(P) for P in bad_primes]
             [I0, I1, I1, II]
             sage: K.<a> = QuadraticField(-11)
@@ -1348,16 +1347,16 @@
            sage: v = K.fractional_ideal(2*i+3)
            sage: EK.reduction(v)
            Elliptic Curve defined by y^2  = x^3 + 5*x + 8 over Residue field of Fractional ideal (2*i + 3)
-           sage: EK.reduction(K.ideal(1+i))     
+           sage: EK.reduction(K.ideal(1+i))
            Traceback (most recent call last):
-           ...  
+           ...
            ValueError: The curve must have good reduction at the place.
-           sage: EK.reduction(K.ideal(2))  
+           sage: EK.reduction(K.ideal(2))
            Traceback (most recent call last):
-           ...  
+           ...
            ValueError: The ideal must be prime.
            sage: K=QQ.extension(x^2+x+1,"a")
-           sage: E=EllipticCurve([1024*K.0,1024*K.0]) 
+           sage: E=EllipticCurve([1024*K.0,1024*K.0])
            sage: E.reduction(2*K)
            Elliptic Curve defined by y^2 + (abar+1)*y = x^3 over Residue field in abar of Fractional ideal (2)
        """
@@ -1375,7 +1374,7 @@
            if local_data.has_good_reduction():
                Fv = OK.residue_field(place)
                return local_data.minimal_model().change_ring(Fv)
-           raise ValueError, "The curve must have good reduction at the place." 
+           raise ValueError, "The curve must have good reduction at the place."
        Fv = OK.residue_field(place)
        return self.change_ring(Fv)
     
@@ -1402,13 +1401,13 @@
         
         EXAMPLES::
 
-            sage: CDB=CremonaDatabase() 
+            sage: CDB=CremonaDatabase()
             sage: [E._torsion_bound() for E in CDB.iter([14])]
             [6, 6, 6, 6, 6, 6]
-            sage: [E.torsion_order() for E in CDB.iter([14])] 
-            [6, 6, 2, 6, 2, 6]    
+            sage: [E.torsion_order() for E in CDB.iter([14])]
+            [6, 6, 2, 6, 2, 6]
         """
-        E = self            
+        E = self
         bound = 0
         k = 0
         K = E.base_field()
@@ -1551,30 +1550,30 @@
             sage: K.<t> = NumberField(x^4 + x^3 + 11*x^2 + 41*x + 101)
             sage: EK = E.base_extend(K)
             sage: EK.torsion_points()
-            [(5 : 5 : 1), 
-            (5 : -6 : 1), 
-            (16 : -61 : 1), 
-            (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : 6/55*t^3 + 3/55*t^2 + 25/11*t + 156/55 : 1), 
-            (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : -7/121*t^3 + 24/121*t^2 + 197/121*t + 16/121 : 1), 
-            (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : -49/121*t^3 - 129/121*t^2 - 315/121*t - 207/121 : 1), 
-            (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : 32/121*t^3 + 60/121*t^2 - 261/121*t - 807/121 : 1), 
-            (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : -6/11*t^3 - 3/11*t^2 - 26/11*t - 321/11 : 1), 
-            (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : 16/121*t^3 - 69/121*t^2 + 293/121*t - 46/121 : 1), 
-            (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : 7/55*t^3 - 24/55*t^2 + 9/11*t + 17/55 : 1), 
-            (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : 34/121*t^3 - 27/121*t^2 + 305/121*t + 708/121 : 1), 
-            (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : 15/121*t^3 + 156/121*t^2 - 232/121*t + 2766/121 : 1), 
-            (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : 6/11*t^3 + 3/11*t^2 + 26/11*t + 310/11 : 1), 
-            (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : -15/121*t^3 - 156/121*t^2 + 232/121*t - 2887/121 : 1), 
-            (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : -34/121*t^3 + 27/121*t^2 - 305/121*t - 829/121 : 1), 
-            (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : -7/55*t^3 + 24/55*t^2 - 9/11*t - 72/55 : 1), 
-            (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : -16/121*t^3 + 69/121*t^2 - 293/121*t - 75/121 : 1), 
-            (t : -1/11*t^3 - 6/11*t^2 - 19/11*t - 59/11 : 1), 
-            (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : -32/121*t^3 - 60/121*t^2 + 261/121*t + 686/121 : 1), 
-            (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : 49/121*t^3 + 129/121*t^2 + 315/121*t + 86/121 : 1), 
-            (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : 7/121*t^3 - 24/121*t^2 - 197/121*t - 137/121 : 1), 
-            (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : -6/55*t^3 - 3/55*t^2 - 25/11*t - 211/55 : 1), 
-            (0 : 1 : 0), 
-            (16 : 60 : 1), 
+            [(5 : 5 : 1),
+            (5 : -6 : 1),
+            (16 : -61 : 1),
+            (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : 6/55*t^3 + 3/55*t^2 + 25/11*t + 156/55 : 1),
+            (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : -7/121*t^3 + 24/121*t^2 + 197/121*t + 16/121 : 1),
+            (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : -49/121*t^3 - 129/121*t^2 - 315/121*t - 207/121 : 1),
+            (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : 32/121*t^3 + 60/121*t^2 - 261/121*t - 807/121 : 1),
+            (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : -6/11*t^3 - 3/11*t^2 - 26/11*t - 321/11 : 1),
+            (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : 16/121*t^3 - 69/121*t^2 + 293/121*t - 46/121 : 1),
+            (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : 7/55*t^3 - 24/55*t^2 + 9/11*t + 17/55 : 1),
+            (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : 34/121*t^3 - 27/121*t^2 + 305/121*t + 708/121 : 1),
+            (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : 15/121*t^3 + 156/121*t^2 - 232/121*t + 2766/121 : 1),
+            (1/11*t^3 - 5/11*t^2 + 19/11*t - 40/11 : 6/11*t^3 + 3/11*t^2 + 26/11*t + 310/11 : 1),
+            (-26/121*t^3 + 20/121*t^2 - 219/121*t - 995/121 : -15/121*t^3 - 156/121*t^2 + 232/121*t - 2887/121 : 1),
+            (-5/121*t^3 + 36/121*t^2 - 84/121*t + 24/121 : -34/121*t^3 + 27/121*t^2 - 305/121*t - 829/121 : 1),
+            (3/55*t^3 + 7/55*t^2 + 2/55*t + 78/55 : -7/55*t^3 + 24/55*t^2 - 9/11*t - 72/55 : 1),
+            (14/121*t^3 - 15/121*t^2 + 90/121*t + 232/121 : -16/121*t^3 + 69/121*t^2 - 293/121*t - 75/121 : 1),
+            (t : -1/11*t^3 - 6/11*t^2 - 19/11*t - 59/11 : 1),
+            (10/121*t^3 + 49/121*t^2 + 168/121*t + 73/121 : -32/121*t^3 - 60/121*t^2 + 261/121*t + 686/121 : 1),
+            (5/121*t^3 - 14/121*t^2 - 158/121*t - 453/121 : 49/121*t^3 + 129/121*t^2 + 315/121*t + 86/121 : 1),
+            (-9/121*t^3 - 21/121*t^2 - 127/121*t - 377/121 : 7/121*t^3 - 24/121*t^2 - 197/121*t - 137/121 : 1),
+            (-3/55*t^3 - 7/55*t^2 - 2/55*t - 133/55 : -6/55*t^3 - 3/55*t^2 - 25/11*t - 211/55 : 1),
+            (0 : 1 : 0),
+            (16 : 60 : 1),
             (t : 1/11*t^3 + 6/11*t^2 + 19/11*t + 48/11 : 1)]
 
         ::
@@ -1583,28 +1582,28 @@
             sage: K.<t> = NumberField(x^2 + 2*x + 10)
             sage: EK = E.base_extend(K)
             sage: EK.torsion_points()
-            [(3 : -2 : 1), 
-            (8 : -27 : 1), 
-            (1/2 : 5/4*t + 1/2 : 1), 
-            (-t - 2 : 2*t + 8 : 1), 
-            (-7 : -5*t - 2 : 1), 
-            (-1 : 0 : 1), 
-            (-2 : 3 : 1), 
-            (-13/4 : 9/8 : 1), 
-            (-2 : -2 : 1), 
-            (t : -2*t + 4 : 1), 
-            (-7 : 5*t + 8 : 1), 
-            (-t - 2 : -t - 7 : 1), 
-            (1/2 : -5/4*t - 2 : 1), 
-            (0 : 1 : 0), 
-            (8 : 18 : 1), 
+            [(3 : -2 : 1),
+            (8 : -27 : 1),
+            (1/2 : 5/4*t + 1/2 : 1),
+            (-t - 2 : 2*t + 8 : 1),
+            (-7 : -5*t - 2 : 1),
+            (-1 : 0 : 1),
+            (-2 : 3 : 1),
+            (-13/4 : 9/8 : 1),
+            (-2 : -2 : 1),
+            (t : -2*t + 4 : 1),
+            (-7 : 5*t + 8 : 1),
+            (-t - 2 : -t - 7 : 1),
+            (1/2 : -5/4*t - 2 : 1),
+            (0 : 1 : 0),
+            (8 : 18 : 1),
             (t : t - 5 : 1)]
         
         ::
     
             sage: K.<i> = QuadraticField(-1)
-            sage: EK = EllipticCurve(K,[0,0,0,0,-1])            
-            sage: EK.torsion_points ()              
+            sage: EK = EllipticCurve(K,[0,0,0,0,-1])
+            sage: EK.torsion_points ()
             [(0 : -i : 1), (1 : 0 : 1), (0 : i : 1), (-2 : 3*i : 1), (0 : 1 : 0), (-2 : -3*i : 1)]
          """
         T = self.torsion_subgroup() # make sure it is cached
@@ -1615,13 +1614,13 @@
         Returns the lower and upper bounds using :meth:`~simon_two_descent`.
         The results of :meth:`~simon_two_descent` are cached.
 
-        .. NOTE:: 
+        .. NOTE::
 
             The optional parameters control the Simon two descent algorithm;
             see the documentation of :meth:`~simon_two_descent` for more
             details.
 
-        INPUT: 
+        INPUT:
 
         - ``verbose`` -- 0, 1, 2, or 3 (default: 0), the verbosity level
 
@@ -1660,7 +1659,7 @@
         bounds on the rank::
 
             sage: Qrt5.<rt5>=NumberField(x^2-5)
-            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])  
+            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])
             sage: E.rank_bounds()
             (1, 2)
 
@@ -1678,13 +1677,13 @@
         r"""
         Return the rank of this elliptic curve, if it can be determined.
 
-        .. NOTE:: 
+        .. NOTE::
 
             The optional parameters control the Simon two descent algorithm;
             see the documentation of :meth:`~simon_two_descent` for more
             details.
 
-        INPUT: 
+        INPUT:
 
         - ``verbose`` -- 0, 1, 2, or 3 (default: 0), the verbosity level
 
@@ -1704,8 +1703,8 @@
 
         If the upper and lower bounds given by Simon two-descent are
         the same, then the rank has been uniquely identified and we
-        return this. Otherwise, we raise a ValueError with an error 
-        message specifying the upper and lower bounds. 
+        return this. Otherwise, we raise a ValueError with an error
+        message specifying the upper and lower bounds.
         
         .. NOTE::
 
@@ -1725,10 +1724,10 @@
         algorithm do not uniquely determine the rank::
 
             sage: Qrt5.<rt5>=NumberField(x^2-5)
-            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])  
+            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])
             sage: E.rank()
             Traceback (most recent call last):
-            ...  
+            ...
             ValueError: There is insufficient data to determine the rank -
             2-descent gave lower bound 1 and upper bound 2
 
@@ -1742,7 +1741,7 @@
         lower,upper = self.rank_bounds(verbose=verbose,lim1=lim1,lim3=lim3,limtriv=limtriv,maxprob=maxprob,limbigprime=limbigprime)
         if lower == upper:
             return lower
-        else: 
+        else:
             raise ValueError, 'There is insufficient data to determine the rank - 2-descent gave lower bound %s and upper bound %s' % (lower, upper)
 
     def gens(self,verbose=0, lim1=5, lim3=50, limtriv=10, maxprob=20, limbigprime=30):
@@ -1750,13 +1749,13 @@
         Returns some generators of this elliptic curve. Check :meth:`~rank` or
         :meth:`~rank_bounds` to verify the number of generators.
 
-        .. NOTE:: 
+        .. NOTE::
 
             The optional parameters control the Simon two descent algorithm;
             see the documentation of :meth:`~simon_two_descent` for more
             details.
 
-        INPUT: 
+        INPUT:
 
         - ``verbose`` -- 0, 1, 2, or 3 (default: 0), the verbosity level
 
@@ -1795,7 +1794,7 @@
         uniquely determine the rank::
 
             sage: Qrt5.<rt5>=NumberField(x^2-5)
-            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])  
+            sage: E=EllipticCurve([0,5-rt5,0,rt5,0])
             sage: E.gens()
             [(3/2*rt5 + 5/2 : -9/2*rt5 - 15/2 : 1), (-1/2*rt5 + 3/2 : 3/2*rt5 - 9/2 : 1), (0 : 0 : 1)]
 
@@ -1817,7 +1816,7 @@
 
         - ``embedding`` - an embedding of the base number field into `\RR` or `\CC`.
 
-        .. note:: 
+        .. note::
 
            The precision of the embedding is ignored: we only use the
            given embedding to determine which embedding into ``QQbar``
@@ -1830,7 +1829,7 @@
         First define a field with two real embeddings::
 
             sage: K.<a> = NumberField(x^3-2)
-            sage: E=EllipticCurve([0,0,0,a,2])                            
+            sage: E=EllipticCurve([0,0,0,a,2])
             sage: embs=K.embeddings(CC); len(embs)
             3
 
@@ -1902,18 +1901,18 @@
             sage: E1 = EllipticCurve(F, [7,8])
             sage: E2 = EllipticCurve(F, [0,5,0,1,0])
             sage: E3 = EllipticCurve(F, [0,-10,0,21,0])
-            sage: E1.is_isogenous(E2)    
+            sage: E1.is_isogenous(E2)
             False
-            sage: E1.is_isogenous(E1) 
+            sage: E1.is_isogenous(E1)
             True
             sage: E2.is_isogenous(E2)
             True
-            sage: E2.is_isogenous(E1) 
+            sage: E2.is_isogenous(E1)
             False
-            sage: E2.is_isogenous(E3) 
+            sage: E2.is_isogenous(E3)
             True
 
-        ::    
+        ::
 
             sage: x = polygen(QQ, 'x')
             sage: F = NumberField(x^2 -2, 's'); F
@@ -1962,7 +1961,7 @@
            True
            sage: E3.is_isogenous(E2)
            True
-           sage: E1.isogeny_degree(E2)            
+           sage: E1.isogeny_degree(E2)
            9
 
         """
@@ -2041,15 +2040,15 @@
             sage: x = QQ['x'].0
             sage: F = NumberField(x^2 -2, 's'); F
             Number Field in s with defining polynomial x^2 - 2
-            sage: E = EllipticCurve('14a1')                    
+            sage: E = EllipticCurve('14a1')
             sage: EE = EllipticCurve('14a2')
             sage: E1 = E.change_ring(F)
             sage: E2 = EE.change_ring(F)
             sage: E1.isogeny_degree(E2)
             2
-            sage: E2.isogeny_degree(E2)     
+            sage: E2.isogeny_degree(E2)
             1
-            sage: E5 = EllipticCurve('14a5').change_ring(F)    
+            sage: E5 = EllipticCurve('14a5').change_ring(F)
             sage: E1.isogeny_degree(E5)
             6
         """
diff --git a/sage/schemes/elliptic_curves/ell_rational_field.py b/sage/schemes/elliptic_curves/ell_rational_field.py
--- a/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -1462,9 +1462,9 @@
         
         ::
         
-            sage: E = EllipticCurve([1, -1, 0, -751055859, -7922219731979])     # long time (0.6 seconds)
-            sage: set_random_seed(0)        # long time
-            sage: E.simon_two_descent ()    # long time
+            sage: E = EllipticCurve([1, -1, 0, -751055859, -7922219731979])
+            sage: set_random_seed(0)
+            sage: E.simon_two_descent()
             (1, 1, [])            
         
         The rest of these entries were taken from Tom Womack's page
@@ -1494,6 +1494,7 @@
             (8, 8)
 
         Example from trac 10832::
+
             sage: E = EllipticCurve([1,0,0,-6664,86543])
             sage: E.simon_two_descent()
             (2, 3, [(173 : 1943 : 1), (-73 : -394 : 1), (323/4 : 1891/8 : 1)])
@@ -1622,19 +1623,19 @@
             2
             sage: EllipticCurve('5077a').rank()
             3
-            sage: EllipticCurve([1, -1, 0, -79, 289]).rank()   # long time.  This will use the default proof behavior of True.
+            sage: EllipticCurve([1, -1, 0, -79, 289]).rank()   # This will use the default proof behavior of True
             4
-            sage: EllipticCurve([0, 0, 1, -79, 342]).rank(proof=False)  # long time -- but under a minute
+            sage: EllipticCurve([0, 0, 1, -79, 342]).rank(proof=False)
             5
-            sage: EllipticCurve([0, 0, 1, -79, 342]).simon_two_descent()[0]  # much faster -- almost instant. 
+            sage: EllipticCurve([0, 0, 1, -79, 342]).simon_two_descent()[0]
             5
         
         Examples with denominators in defining equations::
         
-            sage: E = EllipticCurve( [0, 0, 0, 0, -675/4])
+            sage: E = EllipticCurve([0, 0, 0, 0, -675/4])
             sage: E.rank()
             0
-            sage: E = EllipticCurve( [0, 0, 1/2, 0, -1/5])
+            sage: E = EllipticCurve([0, 0, 1/2, 0, -1/5])
             sage: E.rank()
             1
             sage: E.minimal_model().rank()
@@ -2014,7 +2015,7 @@
         EXAMPLES::
         
             sage: E = EllipticCurve([0, 0, 1, -1, 0])
-            sage: E.regulator()              # long time (1 second)
+            sage: E.regulator()
             0.0511114082399688
             sage: EllipticCurve('11a').regulator()
             1.00000000000000
@@ -2024,9 +2025,9 @@
             0.152460177943144
             sage: EllipticCurve('5077a').regulator()
             0.41714355875838...
-            sage: EllipticCurve([1, -1, 0, -79, 289]).regulator()  # long time (seconds)
+            sage: EllipticCurve([1, -1, 0, -79, 289]).regulator()
             1.50434488827528
-            sage: EllipticCurve([0, 0, 1, -79, 342]).regulator(proof=False)  # long time (seconds)
+            sage: EllipticCurve([0, 0, 1, -79, 342]).regulator(proof=False)  # long time (6s on sage.math, 2011)
             14.790527570131...
         """
         if precision is None:
@@ -2101,8 +2102,8 @@
            regulator of saturated points.
         
         
-        IMPLEMENTATION: Uses Cremona's mwrank package. With max_prime=0,
-        we call mwrank with successively larger prime bounds until the full
+        ALGORITHM: Uses Cremona's ``mwrank`` package. With ``max_prime=0``,
+        we call ``mwrank`` with successively larger prime bounds until the full
         saturation is provably found. The results of saturation at the
         previous primes is stored in each case, so this should be
         reasonably fast.
@@ -2118,7 +2119,7 @@
 
         TESTS:
 
-        See #10590.   This example would loop for ever at default precision::
+        See #10590.  This example would loop for ever at default precision::
 
             sage: E = EllipticCurve([1, 0, 1, -977842, -372252745])
             sage: P = E([-192128125858676194585718821667542660822323528626273/336995568430319276695106602174283479617040716649, 70208213492933395764907328787228427430477177498927549075405076353624188436/195630373799784831667835900062564586429333568841391304129067339731164107, 1])
@@ -2129,9 +2130,8 @@
             sage: E.saturation([2*P]) ## needs higher precision
             ...
             ([(1755450733726721618440965414535034458701302721700399/970334851896750960577261378321772998240802013604 : -59636173615502879504846810677646864329901430096139563516090202443694810309127/955833935771565601591243078845907133814963790187832340692216425242529192 : 1)], 2, 113.302910926080)
-    
-
-        See #10840.  This cause eclib to crash since the curve is
+
+        See #10840.  This causes eclib to crash since the curve is
         non-minimal at 2::
 
             sage: E = EllipticCurve([0,0,0,-13711473216,0])
@@ -2141,7 +2141,6 @@
             sage: S = E([-113288,-9969344])
             sage: E.saturation([P,Q,R,S])
             ([(-19992 : 16313472 : 1), (-24108 : -17791704 : 1), (-97104 : -20391840 : 1), (-113288 : -9969344 : 1)], 1, 172.792031341679)
-            
 
         """
         if not isinstance(points, list):
@@ -3278,7 +3277,7 @@
             sage: E = EllipticCurve('242a1')
             sage: E.modular_degree()
             16
-            sage: E.congruence_number()  # long time
+            sage: E.congruence_number()  # long time (4s on sage.math, 2011)
             176
         
                     
@@ -5710,13 +5709,13 @@
             
         Output checked with Magma (corrected in 3 cases)::
         
-            sage: [len(e.S_integral_points([2], both_signs=False)) for e in cremona_curves([11..100])] # long time
+            sage: [len(e.S_integral_points([2], both_signs=False)) for e in cremona_curves([11..100])] # long time (19s on sage.math, 2011)
             [2, 0, 2, 3, 3, 1, 3, 1, 3, 5, 3, 5, 4, 1, 1, 2, 2, 2, 3, 1, 2, 1, 0, 1, 3, 3, 1, 1, 5, 3, 4, 2, 1, 1, 5, 3, 2, 2, 1, 1, 1, 0, 1, 3, 0, 1, 0, 1, 1, 3, 7, 1, 3, 3, 3, 1, 1, 2, 3, 1, 2, 3, 1, 2, 1, 3, 3, 1, 1, 1, 0, 1, 3, 3, 1, 1, 7, 1, 0, 1, 1, 0, 1, 2, 0, 3, 1, 2, 1, 3, 1, 2, 2, 4, 5, 3, 2, 1, 1, 6, 1, 0, 1, 3, 1, 3, 3, 1, 1, 1, 1, 1, 3, 1, 5, 1, 2, 4, 1, 1, 1, 1, 1, 0, 1, 0, 2, 2, 0, 0, 1, 0, 1, 1, 6, 1, 0, 1, 1, 0, 4, 3, 1, 2, 1, 2, 3, 1, 1, 1, 1, 8, 3, 1, 2, 1, 2, 0, 8, 2, 0, 6, 2, 3, 1, 1, 1, 3, 1, 3, 2, 1, 3, 1, 2, 1, 6, 9, 3, 3, 1, 1, 2, 3, 1, 1, 5, 5, 1, 1, 0, 1, 1, 2, 3, 1, 1, 2, 3, 1, 3, 1, 1, 1, 1, 0, 0, 1, 3, 3, 1, 3, 1, 1, 2, 2, 0, 0, 6, 1, 0, 1, 1, 1, 1, 3, 1, 2, 6, 3, 1, 2, 2, 1, 1, 1, 1, 7, 5, 4, 3, 3, 1, 1, 1, 1, 1, 1, 8, 5, 1, 1, 3, 3, 1, 1, 3, 3, 1, 1, 2, 3, 6, 1, 1, 7, 3, 3, 4, 5, 9, 6, 1, 0, 7, 1, 1, 3, 1, 1, 2, 3, 1, 2, 1, 1, 1, 1, 1, 1, 1, 7, 8, 2, 3, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1]
 
         An example from [PZGH]::
         
             sage: E = EllipticCurve([0,0,0,-172,505])
-            sage: E.rank(), len(E.S_integral_points([3,5,7]))  # long time (~7s)
+            sage: E.rank(), len(E.S_integral_points([3,5,7]))  # long time (5s on sage.math, 2011)
             (4, 72)
 
         This is curve "7690e1" which failed until \#4805 was fixed::
