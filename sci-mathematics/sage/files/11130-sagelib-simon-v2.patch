# HG changeset patch
# User John Cremona <john.cremona@gmail.com>
# Date 1305822334 -3600
# Node ID 35cda75bc998e963b5a76e791a50a50326a8b113
# Parent  53c903189fc34b1abee880e2f27f6a7e34ebf844
#11130: fix doctests for simon_two_descent

diff --git a/sage/schemes/elliptic_curves/ell_number_field.py b/sage/schemes/elliptic_curves/ell_number_field.py
--- a/sage/schemes/elliptic_curves/ell_number_field.py
+++ b/sage/schemes/elliptic_curves/ell_number_field.py
@@ -199,7 +199,7 @@
            For non-quadratic number fields, this code does return, but
            it takes a long time.
 
-        IMPLEMENTATION: 
+        ALGORITHM:
 
         Uses Denis Simon's PARI/GP scripts from
         http://www.math.unicaen.fr/~simon/.
@@ -229,7 +229,7 @@
             listpointsmwr = [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7), 1]]
             (1, 1, [(1/2*a + 3/2 : -a - 2 : 1)])
 
-            sage: v = E.simon_two_descent(verbose=2); v
+            sage: v = E.simon_two_descent(verbose=2)  # random output
             K = bnfinit(y^2 + 7);
             a = Mod(y,K.pol);
             bnfellrank(K, [0,0,0,1,a]);
@@ -237,12 +237,19 @@
             A = 0
             B = Mod(1, y^2 + 7)
             C = Mod(y, y^2 + 7)
-            LS2gen = [Mod(Mod(-5, y^2 + 7)*x^2 + Mod(-3*y, y^2 + 7)*x + Mod(8, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y + 1/2, y^2 + 7)*x - 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
+            LS2gen = [Mod(Mod(-5, y^2 + 7)*x^2 + Mod(-3*y, y^2 + 7)*x + Mod(8, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7)), Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y - 1/2, y^2 + 7)*x - 1, x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))]
             #LS2gen = 2
             Recherche de points triviaux sur la courbe
             points triviaux sur la courbe = [[1, 1, 0], [Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7), 1]]
             zc = Mod(Mod(-5, y^2 + 7)*x^2 + Mod(-3*y, y^2 + 7)*x + Mod(8, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
             symbole de Hilbert (Mod(2, y^2 + 7),Mod(-5, y^2 + 7)) = -1
+            zc = Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y - 1/2, y^2 + 7)*x + Mod(-1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
+            symbole de Hilbert (Mod(-2*y + 2, y^2 + 7),Mod(1, y^2 + 7)) = 0
+            sol de Legendre = [1, 0, 1]~
+            zc*z1^2 = Mod(Mod(2*y - 2, y^2 + 7)*x + Mod(2*y + 10, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
+            quartique : (-1/2*y + 1/2)*Y^2 = x^4 + (-3*y - 15)*x^2 + (-8*y - 16)*x + (-11/2*y - 15/2)
+            reduite: Y^2 = (-1/2*y + 1/2)*x^4 - 4*x^3 + (-3*y + 3)*x^2 + (2*y - 2)*x + (1/2*y + 3/2)
+            non ELS en [2, [0, 1]~, 1, 1, [1, 1]~]
             zc = Mod(Mod(1, y^2 + 7)*x^2 + Mod(1/2*y + 1/2, y^2 + 7)*x + Mod(-1, y^2 + 7), x^3 + Mod(1, y^2 + 7)*x + Mod(y, y^2 + 7))
             vient du point trivial [Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7), 1]
             m1 = 1
@@ -253,6 +260,7 @@
             rang(E/K)     = 1
             listpointsmwr = [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7), 1]]
             v =  [1, 1, [[Mod(1/2*y + 3/2, y^2 + 7), Mod(-y - 2, y^2 + 7)]]]
+            sage: v
             (1, 1, [(1/2*a + 3/2 : -a - 2 : 1)])
 
 
diff --git a/sage/schemes/elliptic_curves/ell_rational_field.py b/sage/schemes/elliptic_curves/ell_rational_field.py
--- a/sage/schemes/elliptic_curves/ell_rational_field.py
+++ b/sage/schemes/elliptic_curves/ell_rational_field.py
@@ -1455,7 +1455,7 @@
             sage: E = EllipticCurve('5077a1')
             sage: set_random_seed(0)
             sage: E.simon_two_descent()
-            (3, 3, [(1 : 0 : 1), (0 : 2 : 1), (2 : -1 : 1)])
+            (3, 3, [(1 : -1 : 1), (2 : 0 : 1), (0 : 2 : 1)])
         
         In this example Simon's program does not find any points, though it
         does correctly compute the rank of the 2-Selmer group.
@@ -1478,7 +1478,7 @@
             (4, 4, [(4 : 3 : 1), (5 : -2 : 1), (6 : -1 : 1), (8 : 7 : 1)])
             sage: E = EllipticCurve([0, 0, 1, -79, 342])
             sage: set_random_seed(0)
-            sage: E.simon_two_descent()
+            sage: E.simon_two_descent()  # long time (9s on sage.math, 2011)
             (5, 5, [(5 : 8 : 1), (4 : 9 : 1), (3 : 11 : 1), (-1 : 20 : 1), (-6 : -25 : 1)])
             sage: E = EllipticCurve([1, 1, 0, -2582, 48720])
             sage: set_random_seed(0)
@@ -1505,10 +1505,16 @@
         """
         t = simon_two_descent(self, verbose=verbose, lim1=lim1, lim3=lim3, limtriv=limtriv,
                               maxprob=maxprob, limbigprime=limbigprime)
+        if t=='fail':
+            raise RuntimeError, 'Run-time error in simon_two_descent.'
+        if verbose>0:
+            print "simon_two_descent returns", t
         rank_low_bd = rings.Integer(t[0])
         two_selmer_rank = rings.Integer(t[1])
         gens_mod_two = [self(P) for P in t[2]]
         if rank_low_bd == two_selmer_rank - self.two_torsion_rank():
+            if verbose>0:
+                print "Rank determined successfully, saturating..."
             gens = [P for P in gens_mod_two if P.has_infinite_order()]
             gens = self.saturation(gens)[0]
             self.__gens[True] = gens
diff --git a/sage/schemes/elliptic_curves/gp_simon.py b/sage/schemes/elliptic_curves/gp_simon.py
--- a/sage/schemes/elliptic_curves/gp_simon.py
+++ b/sage/schemes/elliptic_curves/gp_simon.py
@@ -46,10 +46,12 @@
     """
     Interface to Simon's gp script for two-descent.
 
-    NOTE:
+    .. NOTE::
+
        Users should instead run E.simon_two_descent()
 
-    EXAMPLES:
+    EXAMPLES::
+
         sage: import sage.schemes.elliptic_curves.gp_simon
         sage: E=EllipticCurve('389a1')
         sage: sage.schemes.elliptic_curves.gp_simon.simon_two_descent(E)
@@ -57,7 +59,8 @@
         sage: E.simon_two_descent()
         (2, 2, [(1 : 0 : 1), (-11/9 : -55/27 : 1)])
     
-    TESTS:
+    TESTS::
+
         sage: E = EllipticCurve('37a1').change_ring(QuadraticField(-11,'x'))
         sage: E.simon_two_descent()
         (1, 1, [(-1 : 0 : 1)])
@@ -103,6 +106,8 @@
     if verbose > 0:
         print s
     v = gp.eval('ans')
+    if v=='ans': # then the call to ellrank() or bnfellrank() failed
+        return 'fail'
     if verbose >= 2:
         print "v = ", v
     # pari represents field elements as Mod(poly, defining-poly)
